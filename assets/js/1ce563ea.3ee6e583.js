"use strict";(self.webpackChunkzero_2_hero=self.webpackChunkzero_2_hero||[]).push([[3982],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,g=u["".concat(s,".").concat(p)]||u[p]||h[p]||r;return n?i.createElement(g,o(o({ref:t},c),{},{components:n})):i.createElement(g,o({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9387:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return u}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],l={sidebar_position:1},s="Flutter",d={unversionedId:"flutter/flutter",id:"flutter/flutter",isDocsHomePage:!1,title:"Flutter",description:"Flutter",source:"@site/docs/flutter/flutter.md",sourceDirName:"flutter",slug:"/flutter/flutter",permalink:"/zero2hero/docs/flutter/flutter",editUrl:"https://github.com/sliit-foss/zero2hero/edit/master/docs/flutter/flutter.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Translate your site",permalink:"/zero2hero/docs/tutorial-extras/translate-your-site"},next:{title:"Machine Learning vs AI vs Deep Learning vs Neural Networks",permalink:"/zero2hero/docs/machine-learning/AI ML"}},c=[{value:"1) Installation",id:"1-installation",children:[],level:2},{value:"2) Set up an editor",id:"2-set-up-an-editor",children:[{value:"IDE",id:"ide",children:[],level:3},{value:"Dart",id:"dart",children:[],level:3}],level:2},{value:"3) Create the first project of Flutter",id:"3-create-the-first-project-of-flutter",children:[{value:"Do the coding",id:"do-the-coding",children:[],level:3},{value:"Run the code:",id:"run-the-code",children:[],level:3}],level:2},{value:"4) Introduction to widgets",id:"4-introduction-to-widgets",children:[],level:2},{value:"Hello world",id:"hello-world",children:[],level:2},{value:"5) Basic widgets",id:"5-basic-widgets",children:[{value:"Text",id:"text",children:[],level:3},{value:"Row, Column",id:"row-column",children:[],level:3},{value:"Stack",id:"stack",children:[],level:3},{value:"Container",id:"container",children:[],level:3}],level:2},{value:"6) Using Material Components",id:"6-using-material-components",children:[],level:2},{value:"7) Handling gestures",id:"7-handling-gestures",children:[],level:2},{value:"8) Changing widgets in response to input",id:"8-changing-widgets-in-response-to-input",children:[],level:2},{value:"9) Bringing it all together",id:"9-bringing-it-all-together",children:[],level:2},{value:"10) Responding to widget lifecycle events",id:"10-responding-to-widget-lifecycle-events",children:[],level:2},{value:"11) Keys",id:"11-keys",children:[],level:2},{value:"12) Global keys",id:"12-global-keys",children:[],level:2}],h={toc:c};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"flutter"},"Flutter"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/iMeriem/zero2hero/addFlutterdoc/docs/assets/img/flutter/flutter-lockup.png",alt:"Flutter"}),(0,r.kt)("br",null)),(0,r.kt)("h2",{id:"1-installation"},"1) Installation"),(0,r.kt)("p",null,"There are multiple ways to install Flutter on your system, it also depends on",(0,r.kt)("br",null),"\nthe OS you are using on your machine.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"You can install flutter according to your machine\u2019s OS from the below links:",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Windows : ",(0,r.kt)("a",{parentName:"p",href:"https://flutter.dev/docs/get-started/install/windows"},"https://flutter.dev/docs/get-started/install/windows")," ",(0,r.kt)("br",null),"\nMacOS : ",(0,r.kt)("a",{parentName:"p",href:"https://flutter.dev/docs/get-started/install/macos"},"https://flutter.dev/docs/get-started/install/macos")," ",(0,r.kt)("br",null),"\nLinux:  ",(0,r.kt)("a",{parentName:"p",href:"https://flutter.dev/docs/get-started/install/linux"},"https://flutter.dev/docs/get-started/install/linux")," ",(0,r.kt)("br",null),"\nChrome: ",(0,r.kt)("a",{parentName:"p",href:"https://flutter.dev/docs/get-started/install/chromeos"},"https://flutter.dev/docs/get-started/install/chromeos")," ",(0,r.kt)("br",null)),(0,r.kt)("h2",{id:"2-set-up-an-editor"},"2) Set up an editor"),(0,r.kt)("h3",{id:"ide"},"IDE"),(0,r.kt)("p",null,"To develop Flutter applications, below IDEs are available",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://developer.android.com/studio"},"Android Studio")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://code.visualstudio.com"},"VS Code")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.jetbrains.com/idea/promo/"},"IntelliJ Idea Community / IntelliJ Idea Ultimate")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.gnu.org/software/emacs/download.html"},"Emacs"))),(0,r.kt)("h3",{id:"dart"},"Dart"),(0,r.kt)("p",null,"Dart is completely open source with a clean license.Dart was released by Google",(0,r.kt)("br",null),"\nin 2011 and was initially designed as a replacement for JavaScript.",(0,r.kt)("br",null)),(0,r.kt)("small",null,"To start programming with DART, please refer below official article:"),(0,r.kt)("br",null),(0,r.kt)("small",null," https://dart.dev/guides/language/language-tour"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"3-create-the-first-project-of-flutter"},"3) Create the first project of Flutter"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Open the IDE and select ",(0,r.kt)("strong",{parentName:"li"},"Create New Flutter Project")),(0,r.kt)("li",{parentName:"ol"},"Select ",(0,r.kt)("strong",{parentName:"li"},"Flutter Application")," as the project type. Then click ",(0,r.kt)("strong",{parentName:"li"},"Next"),"."),(0,r.kt)("li",{parentName:"ol"},"Verify the Flutter SDK path specifies the SDK\u2019s location (select Install SDK\u2026 ",(0,r.kt)("be",null),"if the text field is blank)."),(0,r.kt)("li",{parentName:"ol"},"Enter a project name (for example, ",(0,r.kt)("inlineCode",{parentName:"li"},"myapp"),"). Then click Next."),(0,r.kt)("li",{parentName:"ol"},"Click Finish."),(0,r.kt)("li",{parentName:"ol"},"Wait for Android Studio to install the SDK and create the project.")),(0,r.kt)("h3",{id:"do-the-coding"},"Do the coding"),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"main.dart")," file from the lib folder. And replace the code with below:",(0,r.kt)("br",null)),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import \u2018package:flutter/material.dart\u2019;\n\n \nvoid main() => runApp(MyApp());\n\n \n\nclass MyApp extends StatelessWidget {\n\n  @override\n\nWidget build(BuildContext context) {\n\nreturn MaterialApp(\n\n      title: \u2018Welcome to Flutter\u2019,\n\n      home: Scaffold(\n\n        appBar: AppBar(\n\n          title: Text(\u2018Welcome to Flutter\u2019),\n\n        ),\n\n        body: Center(\n\n          child: Text(\u2018Hello World\u2019),\n\n        ),\n\n      ),\n\n    );\n\n  }\n\n}\n\n")),(0,r.kt)("h3",{id:"run-the-code"},"Run the code:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/iMeriem/zero2hero/addFlutterdoc/docs/assets/img/flutter/Screenshot_1.png",alt:"By Clicking the link above download the .exe file"}),(0,r.kt)("br",null)),(0,r.kt)("p",null,"As shown in the above image, from the Android Studio toolbar, click on the Target",(0,r.kt)("br",null)," selector & select simulator / emulator. If none are listed as available, select Tools>",(0,r.kt)("br",null)," Android > AVD Manager and create one there.",(0,r.kt)("br",null),"\nFor details, see Managing AVDs.",(0,r.kt)("br",null)),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/iMeriem/zero2hero/addFlutterdoc/docs/assets/img/flutter/Screenshot_2.png",alt:"By Clicking the link above download the .exe file"})),(0,r.kt)("p",null,"Run the app in the way your IDE describes. You should see either Android, iOS, or web output, depending on your device.",(0,r.kt)("br",null)),(0,r.kt)("h2",{id:"4-introduction-to-widgets"},"4) Introduction to widgets"),(0,r.kt)("p",null,"Flutter widgets are built using a modern framework that takes inspiration from React. The central idea is that you build your UI out of widgets. Widgets describe what their view should look like given their current configuration and state. When a widget\u2019s state changes, the widget rebuilds its description, which the framework diffs against the previous description in order to determine the minimal changes needed in the underlying render tree to transition from one state to the next. "),(0,r.kt)("h2",{id:"hello-world"},"Hello world"),(0,r.kt)("p",null,"The minimal Flutter app simply calls the runApp() function with a widget:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    const Center(\n      child: Text(\n        'Hello, world!',\n        textDirection: TextDirection.ltr,\n      ),\n    ),\n  );\n}\n")),(0,r.kt)("p",null,"The runApp() function takes the given Widget and makes it the root of the widget tree. In this example, the widget tree consists of two widgets, the Center widget and its child, the Text widget. The framework forces the root widget to cover the screen, which means the text \u201cHello, world\u201d ends up centered on screen. The text direction needs to be specified in this instance; when the MaterialApp widget is used, this is taken care of for you, as demonstrated later."),(0,r.kt)("p",null,"When writing an app, you\u2019ll commonly author new widgets that are subclasses of either StatelessWidget or StatefulWidget, depending on whether your widget manages any state. A widget\u2019s main job is to implement a build() function, which describes the widget in terms of other, lower-level widgets. The framework builds those widgets in turn until the process bottoms out in widgets that represent the underlying RenderObject, which computes and describes the geometry of the widget."),(0,r.kt)("h2",{id:"5-basic-widgets"},"5) Basic widgets"),(0,r.kt)("p",null,"Flutter comes with a suite of powerful basic widgets, of which the following are commonly used:"),(0,r.kt)("h3",{id:"text"},"Text"),(0,r.kt)("p",null,"The Text widget lets you create a run of styled text within your application."),(0,r.kt)("h3",{id:"row-column"},"Row, Column"),(0,r.kt)("p",null,"These flex widgets let you create flexible layouts in both the horizontal (Row) and vertical (Column) directions. The design of these objects is based on the web\u2019s flexbox layout model."),(0,r.kt)("h3",{id:"stack"},"Stack"),(0,r.kt)("p",null,"Instead of being linearly oriented (either horizontally or vertically), a Stack widget lets you place widgets on top of each other in paint order. You can then use the Positioned widget on children of a Stack to position them relative to the top, right, bottom, or left edge of the stack. Stacks are based on the web\u2019s absolute positioning layout model."),(0,r.kt)("h3",{id:"container"},"Container"),(0,r.kt)("p",null,"The Container widget lets you create a rectangular visual element. A container can be decorated with a BoxDecoration, such as a background, a border, or a shadow. A Container can also have margins, padding, and constraints applied to its size. In addition, a Container can be transformed in three dimensional space using a matrix."),(0,r.kt)("p",null,"Below are some simple widgets that combine these and other widgets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nclass MyAppBar extends StatelessWidget {\n  const MyAppBar({required this.title, Key? key}) : super(key: key);\n\n  // Fields in a Widget subclass are always marked \"final\".\n\n  final Widget title;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 56.0, // in logical pixels\n      padding: const EdgeInsets.symmetric(horizontal: 8.0),\n      decoration: BoxDecoration(color: Colors.blue[500]),\n      // Row is a horizontal, linear layout.\n      child: Row(\n        // <Widget> is the type of items in the list.\n        children: [\n          const IconButton(\n            icon: Icon(Icons.menu),\n            tooltip: 'Navigation menu',\n            onPressed: null, // null disables the button\n          ),\n          // Expanded expands its child\n          // to fill the available space.\n          Expanded(\n            child: title,\n          ),\n          const IconButton(\n            icon: Icon(Icons.search),\n            tooltip: 'Search',\n            onPressed: null,\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass MyScaffold extends StatelessWidget {\n  const MyScaffold({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Material is a conceptual piece\n    // of paper on which the UI appears.\n    return Material(\n      // Column is a vertical, linear layout.\n      child: Column(\n        children: [\n          MyAppBar(\n            title: Text(\n              'Example title',\n              style: Theme.of(context) //\n                  .primaryTextTheme\n                  .headline6,\n            ),\n          ),\n          const Expanded(\n            child: Center(\n              child: Text('Hello, world!'),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      title: 'My app', // used by the OS task switcher\n      home: SafeArea(\n        child: MyScaffold(),\n      ),\n    ),\n  );\n}\n")),(0,r.kt)("p",null,"Be sure to have a uses-material-design: true entry in the flutter section of your pubspec.yaml file. It allows you to use the predefined set of Material icons. It\u2019s generally a good idea to include this line if you are using the Materials library."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"\n  name: my_app\n  flutter:\n  uses-material-design: true\n\n\n")),(0,r.kt)("p",null,"The MyAppBar widget creates a Container with a height of 56 device-independent pixels with an internal padding of 8 pixels, both on the left and the right. Inside the container, MyAppBar uses a Row layout to organize its children. The middle child, the title widget, is marked as Expanded, which means it expands to fill any remaining available space that hasn\u2019t been consumed by the other children. You can have multiple Expanded children and determine the ratio in which they consume the available space using the flex argument to Expanded."),(0,r.kt)("p",null,"The MyScaffold widget organizes its children in a vertical column. At the top of the column it places an instance of MyAppBar, passing the app bar a Text widget to use as its title. Passing widgets as arguments to other widgets is a powerful technique that lets you create generic widgets that can be reused in a wide variety of ways. Finally, MyScaffold uses an Expanded to fill the remaining space with its body, which consists of a centered message."),(0,r.kt)("h2",{id:"6-using-material-components"},"6) Using Material Components"),(0,r.kt)("p",null,"Flutter provides a number of widgets that help you build apps that follow Material Design. A Material app starts with the MaterialApp widget, which builds a number of useful widgets at the root of your app, including a Navigator, which manages a stack of widgets identified by strings, also known as \u201croutes\u201d. The Navigator lets you transition smoothly between screens of your application. Using the MaterialApp widget is entirely optional but a good practice."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      title: 'Flutter Tutorial',\n      home: TutorialHome(),\n    ),\n  );\n}\n\nclass TutorialHome extends StatelessWidget {\n  const TutorialHome({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Scaffold is a layout for\n    // the major Material Components.\n    return Scaffold(\n      appBar: AppBar(\n        leading: const IconButton(\n          icon: Icon(Icons.menu),\n          tooltip: 'Navigation menu',\n          onPressed: null,\n        ),\n        title: const Text('Example title'),\n        actions: const [\n          IconButton(\n            icon: Icon(Icons.search),\n            tooltip: 'Search',\n            onPressed: null,\n          ),\n        ],\n      ),\n      // body is the majority of the screen.\n      body: const Center(\n        child: Text('Hello, world!'),\n      ),\n      floatingActionButton: const FloatingActionButton(\n        tooltip: 'Add', // used by assistive technologies\n        child: Icon(Icons.add),\n        onPressed: null,\n      ),\n    );\n  }\n}\n")),(0,r.kt)("p",null,"Now that the code has switched from MyAppBar and MyScaffold to the AppBar and Scaffold widgets, and from material.dart, the app is starting to look a bit more Material. For example, the app bar has a shadow and the title text inherits the correct styling automatically. A floating action button is also added."),(0,r.kt)("p",null,"Notice that widgets are passed as arguments to other widgets. The Scaffold widget takes a number of different widgets as named arguments, each of which are placed in the Scaffold layout in the appropriate place. Similarly, the AppBar widget lets you pass in widgets for the leading widget, and the actions of the title widget. This pattern recurs throughout the framework and is something you might consider when designing your own widgets."),(0,r.kt)("h2",{id:"7-handling-gestures"},"7) Handling gestures"),(0,r.kt)("p",null,"Most applications include some form of user interaction with the system. The first step in building an interactive application is to detect input gestures. See how that works by creating a simple button:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nclass MyButton extends StatelessWidget {\n  const MyButton({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        print('MyButton was tapped!');\n      },\n      child: Container(\n        height: 50.0,\n        padding: const EdgeInsets.all(8.0),\n        margin: const EdgeInsets.symmetric(horizontal: 8.0),\n        decoration: BoxDecoration(\n          borderRadius: BorderRadius.circular(5.0),\n          color: Colors.lightGreen[500],\n        ),\n        child: const Center(\n          child: Text('Engage'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: MyButton(),\n        ),\n      ),\n    ),\n  );\n}\n")),(0,r.kt)("p",null,"The GestureDetector widget doesn\u2019t have a visual representation but instead detects gestures made by the user. When the user taps the Container, the GestureDetector calls its onTap() callback, in this case printing a message to the console. You can use GestureDetector to detect a variety of input gestures, including taps, drags, and scales."),(0,r.kt)("p",null,"Many widgets use a GestureDetector to provide optional callbacks for other widgets. For example, the IconButton, ElevatedButton, and FloatingActionButton widgets have onPressed() callbacks that are triggered when the user taps the widget."),(0,r.kt)("h2",{id:"8-changing-widgets-in-response-to-input"},"8) Changing widgets in response to input"),(0,r.kt)("p",null,"So far, this page has used only stateless widgets. Stateless widgets receive arguments from their parent widget, which they store in final member variables. When a widget is asked to build(), it uses these stored values to derive new arguments for the widgets it creates."),(0,r.kt)("p",null,"In order to build more complex experiences\u2014for example, to react in more interesting ways to user input\u2014applications typically carry some state. Flutter uses StatefulWidgets to capture this idea. StatefulWidgets are special widgets that know how to generate State objects, which are then used to hold state. Consider this basic example, using the ElevatedButton mentioned earlier:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nclass Counter extends StatefulWidget {\n  // This class is the configuration for the state.\n  // It holds the values (in this case nothing) provided\n  // by the parent and used by the build  method of the\n  // State. Fields in a Widget subclass are always marked\n  // \"final\".\n\n  const Counter({Key? key}) : super(key: key);\n\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int _counter = 0;\n\n  void _increment() {\n    setState(() {\n      // This call to setState tells the Flutter framework\n      // that something has changed in this State, which\n      // causes it to rerun the build method below so that\n      // the display can reflect the updated values. If you\n      // change _counter without calling setState(), then\n      // the build method won't be called again, and so\n      // nothing would appear to happen.\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // This method is rerun every time setState is called,\n    // for instance, as done by the _increment method above.\n    // The Flutter framework has been optimized to make\n    // rerunning build methods fast, so that you can just\n    // rebuild anything that needs updating rather than\n    // having to individually changes instances of widgets.\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        ElevatedButton(\n          onPressed: _increment,\n          child: const Text('Increment'),\n        ),\n        const SizedBox(width: 16),\n        Text('Count: $_counter'),\n      ],\n    );\n  }\n}\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Counter(),\n        ),\n      ),\n    ),\n  );\n}\n")),(0,r.kt)("p",null,"You might wonder why StatefulWidget and State are separate objects. In Flutter, these two types of objects have different life cycles. Widgets are temporary objects, used to construct a presentation of the application in its current state. State objects, on the other hand, are persistent between calls to build(), allowing them to remember information."),(0,r.kt)("p",null,"The example above accepts user input and directly uses the result in its build() method. In more complex applications, different parts of the widget hierarchy might be responsible for different concerns; for example, one widget might present a complex user interface with the goal of gathering specific information, such as a date or location, while another widget might use that information to change the overall presentation."),(0,r.kt)("p",null,"In Flutter, change notifications flow \u201cup\u201d the widget hierarchy by way of callbacks, while current state flows \u201cdown\u201d to the stateless widgets that do presentation. The common parent that redirects this flow is the State. The following slightly more complex example shows how this works in practice:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nclass CounterDisplay extends StatelessWidget {\n  const CounterDisplay({required this.count, Key? key}) : super(key: key);\n\n  final int count;\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Count: $count');\n  }\n}\n\nclass CounterIncrementor extends StatelessWidget {\n  const CounterIncrementor({required this.onPressed, Key? key})\n      : super(key: key);\n\n  final VoidCallback onPressed;\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      child: const Text('Increment'),\n    );\n  }\n}\n\nclass Counter extends StatefulWidget {\n  const Counter({Key? key}) : super(key: key);\n\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int _counter = 0;\n\n  void _increment() {\n    setState(() {\n      ++_counter;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        CounterIncrementor(onPressed: _increment),\n        const SizedBox(width: 16),\n        CounterDisplay(count: _counter),\n      ],\n    );\n  }\n}\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Counter(),\n        ),\n      ),\n    ),\n  );\n}\n")),(0,r.kt)("p",null,"Notice the creation of two new stateless widgets, cleanly separating the concerns of displaying the counter (CounterDisplay) and changing the counter (CounterIncrementor). Although the net result is the same as the previous example, the separation of responsibility allows greater complexity to be encapsulated in the individual widgets, while maintaining simplicity in the parent."),(0,r.kt)("h2",{id:"9-bringing-it-all-together"},"9) Bringing it all together"),(0,r.kt)("p",null,"What follows is a more complete example that brings together these concepts: A hypothetical shopping application displays various products offered for sale, and maintains a shopping cart for intended purchases. Start by defining the presentation class, ShoppingListItem:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nclass Product {\n  const Product({required this.name});\n\n  final String name;\n}\n\ntypedef CartChangedCallback = Function(Product product, bool inCart);\n\nclass ShoppingListItem extends StatelessWidget {\n  ShoppingListItem({\n    required this.product,\n    required this.inCart,\n    required this.onCartChanged,\n  }) : super(key: ObjectKey(product));\n\n  final Product product;\n  final bool inCart;\n  final CartChangedCallback onCartChanged;\n\n  Color _getColor(BuildContext context) {\n    // The theme depends on the BuildContext because different\n    // parts of the tree can have different themes.\n    // The BuildContext indicates where the build is\n    // taking place and therefore which theme to use.\n\n    return inCart //\n        ? Colors.black54\n        : Theme.of(context).primaryColor;\n  }\n\n  TextStyle? _getTextStyle(BuildContext context) {\n    if (!inCart) return null;\n\n    return const TextStyle(\n      color: Colors.black54,\n      decoration: TextDecoration.lineThrough,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      onTap: () {\n        onCartChanged(product, inCart);\n      },\n      leading: CircleAvatar(\n        backgroundColor: _getColor(context),\n        child: Text(product.name[0]),\n      ),\n      title: Text(product.name, style: _getTextStyle(context)),\n    );\n  }\n}\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: ShoppingListItem(\n            product: const Product(name: 'Chips'),\n            inCart: true,\n            onCartChanged: (product, inCart) {},\n          ),\n        ),\n      ),\n    ),\n  );\n}\n")),(0,r.kt)("p",null,"The ShoppingListItem widget follows a common pattern for stateless widgets. It stores the values it receives in its constructor in final member variables, which it then uses during its build() function. For example, the inCart boolean toggles between two visual appearances: one that uses the primary color from the current theme, and another that uses gray."),(0,r.kt)("p",null,"When the user taps the list item, the widget doesn\u2019t modify its inCart value directly. Instead, the widget calls the onCartChanged function it received from its parent widget. This pattern lets you store state higher in the widget hierarchy, which causes the state to persist for longer periods of time. In the extreme, the state stored on the widget passed to runApp() persists for the lifetime of the application."),(0,r.kt)("p",null,"When the parent receives the onCartChanged callback, the parent updates its internal state, which triggers the parent to rebuild and create a new instance of ShoppingListItem with the new inCart value. Although the parent creates a new instance of ShoppingListItem when it rebuilds, that operation is cheap because the framework compares the newly built widgets with the previously built widgets and applies only the differences to the underlying RenderObject."),(0,r.kt)("p",null,"Here\u2019s an example parent widget that stores mutable state:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"import 'package:flutter/material.dart';\n\nclass Product {\n  const Product({required this.name});\n\n  final String name;\n}\n\ntypedef CartChangedCallback = Function(Product product, bool inCart);\n\nclass ShoppingListItem extends StatelessWidget {\n  ShoppingListItem({\n    required this.product,\n    required this.inCart,\n    required this.onCartChanged,\n  }) : super(key: ObjectKey(product));\n\n  final Product product;\n  final bool inCart;\n  final CartChangedCallback onCartChanged;\n\n  Color _getColor(BuildContext context) {\n    // The theme depends on the BuildContext because different\n    // parts of the tree can have different themes.\n    // The BuildContext indicates where the build is\n    // taking place and therefore which theme to use.\n\n    return inCart //\n        ? Colors.black54\n        : Theme.of(context).primaryColor;\n  }\n\n  TextStyle? _getTextStyle(BuildContext context) {\n    if (!inCart) return null;\n\n    return const TextStyle(\n      color: Colors.black54,\n      decoration: TextDecoration.lineThrough,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      onTap: () {\n        onCartChanged(product, inCart);\n      },\n      leading: CircleAvatar(\n        backgroundColor: _getColor(context),\n        child: Text(product.name[0]),\n      ),\n      title: Text(\n        product.name,\n        style: _getTextStyle(context),\n      ),\n    );\n  }\n}\n\nclass ShoppingList extends StatefulWidget {\n  const ShoppingList({required this.products, Key? key}) : super(key: key);\n\n  final List<Product> products;\n\n  // The framework calls createState the first time\n  // a widget appears at a given location in the tree.\n  // If the parent rebuilds and uses the same type of\n  // widget (with the same key), the framework re-uses\n  // the State object instead of creating a new State object.\n\n  @override\n  _ShoppingListState createState() => _ShoppingListState();\n}\n\nclass _ShoppingListState extends State<ShoppingList> {\n  final _shoppingCart = <Product>{};\n\n  void _handleCartChanged(Product product, bool inCart) {\n    setState(() {\n      // When a user changes what's in the cart, you need\n      // to change _shoppingCart inside a setState call to\n      // trigger a rebuild.\n      // The framework then calls build, below,\n      // which updates the visual appearance of the app.\n\n      if (!inCart) {\n        _shoppingCart.add(product);\n      } else {\n        _shoppingCart.remove(product);\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Shopping List'),\n      ),\n      body: ListView(\n        padding: const EdgeInsets.symmetric(vertical: 8.0),\n        children: widget.products.map((Product product) {\n          return ShoppingListItem(\n            product: product,\n            inCart: _shoppingCart.contains(product),\n            onCartChanged: _handleCartChanged,\n          );\n        }).toList(),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(const MaterialApp(\n    title: 'Shopping App',\n    home: ShoppingList(\n      products: [\n        Product(name: 'Eggs'),\n        Product(name: 'Flour'),\n        Product(name: 'Chocolate chips'),\n      ],\n    ),\n  ));\n}\n")),(0,r.kt)("p",null,"The ShoppingList class extends StatefulWidget, which means this widget stores mutable state. When the ShoppingList widget is first inserted into the tree, the framework calls the createState() function to create a fresh instance of _ShoppingListState to associate with that location in the tree. (Notice that subclasses of State are typically named with leading underscores to indicate that they are private implementation details.) When this widget\u2019s parent rebuilds, the parent creates a new instance of ShoppingList, but the framework reuses the _ShoppingListState instance that is already in the tree rather than calling createState again."),(0,r.kt)("p",null,"To access properties of the current ShoppingList, the _ShoppingListState can use its widget property. If the parent rebuilds and creates a new ShoppingList, the _ShoppingListState rebuilds with the new widget value. If you wish to be notified when the widget property changes, override the didUpdateWidget() function, which is passed an oldWidget to let you compare the old widget with the current widget."),(0,r.kt)("p",null,"When handling the onCartChanged callback, the _ShoppingListState mutates its internal state by either adding or removing a product from _shoppingCart. To signal to the framework that it changed its internal state, it wraps those calls in a setState() call. Calling setState marks this widget as dirty and schedules it to be rebuilt the next time your app needs to update the screen. If you forget to call setState when modifying the internal state of a widget, the framework won\u2019t know your widget is dirty and might not call the widget\u2019s build() function, which means the user interface might not update to reflect the changed state. By managing state in this way, you don\u2019t need to write separate code for creating and updating child widgets. Instead, you simply implement the build function, which handles both situations."),(0,r.kt)("h2",{id:"10-responding-to-widget-lifecycle-events"},"10) Responding to widget lifecycle events"),(0,r.kt)("p",null,"After calling createState() on the StatefulWidget, the framework inserts the new state object into the tree and then calls initState() on the state object. A subclass of State can override initState to do work that needs to happen just once. For example, override initState to configure animations or to subscribe to platform services. Implementations of initState are required to start by calling super.initState."),(0,r.kt)("p",null,"When a state object is no longer needed, the framework calls dispose() on the state object. Override the dispose function to do cleanup work. For example, override dispose to cancel timers or to unsubscribe from platform services. Implementations of dispose typically end by calling super.dispose."),(0,r.kt)("h2",{id:"11-keys"},"11) Keys"),(0,r.kt)("p",null,"Use keys to control which widgets the framework matches up with other widgets when a widget rebuilds. By default, the framework matches widgets in the current and previous build according to their runtimeType and the order in which they appear. With keys, the framework requires that the two widgets have the same key as well as the same runtimeType."),(0,r.kt)("p",null,"Keys are most useful in widgets that build many instances of the same type of widget. For example, the ShoppingList widget, which builds just enough ShoppingListItem instances to fill its visible region:"),(0,r.kt)("p",null,"Without keys, the first entry in the current build would always sync with the first entry in the previous build, even if, semantically, the first entry in the list just scrolled off screen and is no longer visible in the viewport."),(0,r.kt)("p",null,"By assigning each entry in the list a \u201csemantic\u201d key, the infinite list can be more efficient because the framework syncs entries with matching semantic keys and therefore similar (or identical) visual appearances. Moreover, syncing the entries semantically means that state retained in stateful child widgets remains attached to the same semantic entry rather than the entry in the same numerical position in the viewport."),(0,r.kt)("h2",{id:"12-global-keys"},"12) Global keys"),(0,r.kt)("p",null,"Use global keys to uniquely identify child widgets. Global keys must be globally unique across the entire widget hierarchy, unlike local keys which need only be unique among siblings. Because they are globally unique, a global key can be used to retrieve the state associated with a widget."))}u.isMDXComponent=!0}}]);